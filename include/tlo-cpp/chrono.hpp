#ifndef TLO_CPP_CHRONO_HPP
#define TLO_CPP_CHRONO_HPP

#include <cassert>
#include <chrono>
#include <ctime>
#include <limits>
#include <string>

namespace tlo {
namespace internal {
template <class Duration, class Rep = typename Duration::rep>
constexpr Duration maxDuration() noexcept {
  return Duration{std::numeric_limits<Rep>::max()};
}

template <class Duration>
constexpr Duration absDuration(const Duration d) noexcept {
  return Duration{(d.count() < 0) ? -d.count() : d.count()};
}
}  // namespace internal

// Convert from one type of std::chrono::time_point to another, even if they
// are on different clocks. The conversion may have some error. Based on code
// from https://stackoverflow.com/questions/35282308/convert-between-c11-clocks
template <typename DstTimePoint, typename SrcTimePoint,
          typename DstDuration = typename DstTimePoint::duration,
          typename SrcDuration = typename SrcTimePoint::duration,
          typename DstClock = typename DstTimePoint::clock,
          typename SrcClock = typename SrcTimePoint::clock>
DstTimePoint convertTimePoint(
    const SrcTimePoint timePoint,
    const SrcDuration tolerance = std::chrono::nanoseconds{100},
    const int limit = 10) {
  assert(limit > 0);

  SrcTimePoint srcNow;
  DstTimePoint dstNow;
  auto epsilon = internal::maxDuration<SrcDuration>();

  for (auto i = 0; epsilon > tolerance && i < limit; ++i) {
    const auto srcBefore = SrcClock::now();
    const auto dstBetween = DstClock::now();
    const auto srcAfter = SrcClock::now();
    const auto srcDiff = srcAfter - srcBefore;
    const auto delta = internal::absDuration(srcDiff);

    if (delta < epsilon) {
      srcNow = srcBefore + srcDiff / 2;
      dstNow = dstBetween;
      epsilon = delta;
    }
  }

  return dstNow + std::chrono::duration_cast<DstDuration>(timePoint - srcNow);
}

// Converts timeObject to a timestamp that preserves all the fields of the
// std::tm object. The beginning of the timestamp is in "%Y-%m-%d %H:%M:%S"
// format. Returns the timestamp.
std::string toTimestamp(const std::tm &timeObject);

// Calls std::localtime(&time) then passes the resulting std::tm object to
// toTimestamp(). Returns the timestamp. Thread-safe when called in multiple
// threads concurrently. Not thread-safe when called concurrently with other
// functions that also call std::localTime(), std::gmtime(), or std::ctime().
std::string toLocalTimestamp(std::time_t time);

// Fills the tm according to the given timestamp. Assumes timestamp is in the
// format returned by toTimestamp(). Throws std::runtime_error if timestamp
// fails parsing. This function does the reverse of toTimestamp().
void toTm(std::tm &timeObject, const std::string &timestamp);

// Calls toTm(..., localTimestamp) then passes the filled std::tm object to
// std::mktime() and returns the result. Assumes localTimestamp was generated
// by toLocalTimestamp(). This function does the reverse of toLocalTimestamp().
std::time_t toTimeT(const std::string &localTimestamp);

// Returns whether the given timestamps differ by at most maxSecondDifference
// seconds. Assumes the timestamps were generated by toLocalTimestamp(). Throws
// std::runtime_error if any of the timestamps fail parsing.
bool equalTimestamps(const std::string &localTimestamp1,
                     const std::string &localTimestamp2,
                     int maxSecondDifference);
}  // namespace tlo

#endif  // TLO_CPP_CHRONO_HPP
